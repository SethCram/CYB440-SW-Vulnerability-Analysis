//CADET's first C program

#include "libcgc.h"
#include "libc.h"
#include "stdlib.h"

#define HI "\nWelcome to Palindrome Finder\n\n"
#define ASK "\tPlease enter a possible palindrome: "
#define YES "\n\t\tYes, that's a palindrome!\n\n"
#define NO "\n\t\tNope, that's not a palindrome\n\n"
#define EASTEREGG "\n\nEASTER EGG!\n\n"
#define ERR "\n Error in allocate \n"
#define NOERR "\n No error in allocate\n "
#define SIZE_IS "\n You entered this many characters: "
int check();
char* itoa(int num, char* str, int base);
  
int main(void ){
    int r;
    char buf1[100];

    if (transmit_all(1, HI, sizeof(HI)-1) != 0) {
        _terminate(0);
    }
    
    void*buf;
    int res=allocate(128,0,&buf);
    if(res!=0) {
      sprintf(buf1,"\nError in allocate: %d %x\n",res,&buf);
	
      if (transmit_all(1, buf1, strlen(buf1)) != 0) {
	  _terminate(0);
      }

    } 
	
	     
    while(1){
        if (transmit_all(1, ASK, sizeof(ASK)-1) != 0) {
            _terminate(0);
        }
        r = check();
        if (r == -1){
            break;
        }
        else if (r != 0){
            if (transmit_all(1, NO, sizeof(NO)-1) != 0) {
                _terminate(0);
            }
        }
        else{
            if (transmit_all(1, YES, sizeof(YES)-1) != 0) {
                _terminate(0);
            }
        }
    }
    return 0;
}

int check(){
    int len = -1;
    int i;
    int pal = 0;
    char string[64];
    char sizeStr[32];
    for (i = 0; i < sizeof(string); i++)
        string[i] = '\0';

    for (i = 0; i < sizeof(sizeStr); i++)
        sizeStr[i] = '\0';
    
    if (receive_delim(0, string, 128, '\n') != 0)
        return -1;

    len=-1;
    for(i = 0; string[i] != '\0'; i++){
        len++;
    }
                   
    itoa(len,sizeStr,10);
    transmit_all(1, SIZE_IS, sizeof(SIZE_IS)-1);
    transmit_all(1, sizeStr, sizeof(sizeStr)-1);         
      
    int steps = len;
    if(len % 2 == 1){
        steps--;
    }
    for(i = 0; i <= steps/2; i++){
        if(string[i] != string[len-1-i]){
            pal = 1;
        }
    }
    if(string[0] == '^'){
        if (transmit_all(1, EASTEREGG, sizeof(EASTEREGG)-1) != 0) {
            _terminate(0);
        }
    }    
    return pal;
}

void reverse(char str[], int length) 
{ 
    int start = 0; 
    int end = length -1;
    char tmp;
    while (start < end) 
    { 
        tmp=*(str+end);
        *(str+end)=*(str+start);
        *(str+start)=tmp;
        start++; 
        end--; 
    } 
} 

char* itoa(int num, char* str, int base) 
{ 
    int i = 0; 
    int isNegative = 0; 

    
    /* Handle 0 explicitely, otherwise empty string is printed for 0 */
    if (num == 0) 
    { 
        str[i++] = '0'; 
        str[i] = '\0'; 
        return str; 
    } 
  
    // In standard itoa(), negative numbers are handled only with  
    // base 10. Otherwise numbers are considered unsigned. 
    if (num < 0 && base == 10) 

      { 
        isNegative = 1; 
        num = -num; 
    } 
  
    // Process individual digits 
    while (num != 0) 
    { 
        int rem = num % base; 
        str[i++] = (rem > 9)? (rem-10) + 'a' : rem + '0'; 
        num = num/base; 
    } 
  
    // If number is negative, append '-' 
    if (isNegative) 
        str[i++] = '-'; 
  
    str[i] = '\0'; // Append string terminator 
  
    // Reverse the string 
    reverse(str, i); 
  
    return str; 
} 
